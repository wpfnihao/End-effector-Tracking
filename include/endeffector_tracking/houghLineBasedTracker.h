/**
 * @file houghLineBasedTracker.h
 * @brief the head file of the houghLineBasedTracker.
 * @author Pengfei Wu - wpfnihao@gmail.com
 * @version 1.0
 * @date 2013-05-23
 */

#include <ros/ros.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <image_transport/image_transport.h>

//OpenCV headers
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
// for Kalman filter
#include <opencv2/video/tracking.hpp>

//visp headers
//the vpMbTracker class, used to get the initial pose
#include <visp/vpMbEdgeTracker.h>
//the vpPose classs, used to calc pose from features
//the vpHomogeneousMatrix.h is also included in this head file
#include <visp/vpPose.h>
#include <visp/vpImage.h>
#include <visp/vpCameraParameters.h>
#include <visp/vpPoseFeatures.h>

//#include <conversions/image.h>

// std headers
#include <vector>
#include <iostream>
#include <cmath>

//TODO: this class should be reimplemented by inherit from the cadModel class
class houghLineBasedTracker
{
// enum, typedef, struct, class ...
public:
	
	/**
	 * @brief  lines to describe the model in the object frame
	 */
	typedef std::vector<cv::Point3f> modelLine;

	/**
	 * @brief  line detected by hough transform with a corresponding line in the object model.
     *  		both straight line and line segment are saved in this struct
	 *  		with their corresponding coordinates in object frame.
	 */
	typedef struct detectedLine_
	{
		vpLine vl; 			// straight Line
		vpPoint p1, p2; 	// line segment
		int lineID; 		// ID of the line in the cad model of the target object
		int detectID; 		// detected line ID
	} detectedLine;

//member variable
private:

	/**
	 * @brief  Kalman filter, tracking the pose (cMo).
	 * 			 cMo is a 4*4 matrix, however the state has 6 measurements (pose Vector) and 6 velocities of the measurement.
	 */
	cv::KalmanFilter KF;

	/* current state */

	/**
	 * @brief  lines generated by hough transform
	 */
	std::vector<cv::Vec4f> lines;


	// pose here is either generated manually or measured by the connected hough lines

	/**
	 * @brief  	the current pose
	 */
	vpHomogeneousMatrix cMo;
	/**
	 * @brief  the pose vector corresponding to the pose matrix
	 * 			tx, ty, tz, thetaux, thetauy, thetauz
	 */
	vpPoseVector poseVector;

	/**
	 * @brief  current window for hough
	 *  p1 let up
	 *  p2 right bottom
	 *  window: x1, y1, x2, y2
	 */
	int window[4];

	/**
	 * @brief current cvImg maintained by the class
	 * 			TODO: the maintaining of the img
	 */
	cv::Mat curImg;
	cv::Mat processedImg;

	/* End of current state */
	
	vpCameraParameters cam;

	/* Global state */
	/**
	 * @brief  rows and cols
	 * 			TODO: the maintaining of the params
	 *
	 */
	int rows, cols;
	
	/**
	 * @brief if tracking lost, this flag will be set true
	 * 			TODO: publish it to the outside 
	 */
	bool isLost;

	// the cube
	/**
	 * @brief  cube corners
	 */
	std::vector<cv::Point3f> corners;

	/**
	 * @brief  cube lines
	 */
	std::vector<modelLine> model;

	/**
	 * @brief  the polygon form description of the cube
	 * 			VERY IMPORTANT:
	 * 			new operator used in vpMbtPolygon class and operator=() is NOT redefined in the class, which means the vpMbtPolygon instants should be instantiated in the constructor of this class, if not, the data will NOT be properly copied during push_back and the whole program will crash.
	 * 			vpMbtPolygon pyg1, pyg2, pyg3, pyg4, pyg5, pyg6;
	 */
	vpMbtPolygon pyg[6];
	/* End of global state */




	/* predicted state */
	/**
	 * @brief  predicted cMo
	 */
	vpHomogeneousMatrix p_cMo;

	/**
	 * @brief  predicted pose
	 */
	vpPoseVector p_Pose;
	/* End of predicted state */




	/* projected model */
	/**
	 * @brief  projected cube lines by the current pose (a.k.a. cMo)
	 */
	std::vector<cv::Vec4f> prjModel;

	/**
	 * @brief  projected corners
	 */
	std::vector<cv::Point2f> prjCorners;

	/**
	 * @brief  is the line visible in current pose?
	 */
	bool isVisible[12];

	/**
	 * @brief  hough detected corresponding visible lines
	 */
	std::vector<detectedLine> detectedModel;

	/**
	 * @brief  maybe not used, since we can use the predicted pose as the initial pose for tracking
	 * corners of the detected lines
	 */
	std::vector<vpPoint> detectedCorners;
	/* End of predicted model */

// member functions
public:
	/**
	 * @brief  constructor
	 */
	houghLineBasedTracker();
			
	/**
	 * @brief  brief project the model based on the obtained cMo and init the Kalman filter.
	 *
	 * @param cam_ the camera param
	 * @param cMo_ the initial pose matrix
	 * @param pose the initial pose vector
	 * @param rows_ rows of image
	 * @param cols_ cols of image
	 */
	void initialize(const vpCameraParameters& cam_, const vpHomogeneousMatrix& cMo_, const vpPoseVector& pose, int rows_, int cols_);

	/**
	 * @brief  publish the tracked rst to the upper level
	 *
	 * @param img image with the tracker markers
	 * @param box tracked box
	 *
	 * @return whether the tracker is lost target
	 */
	bool pubRst(cv::Mat& img, cv::Rect& box);

	/**
	 * @brief 		retrieve Image from the up level class
	 *
	 * @param img 	the input image
	 */
	void retrieveImage(const cv::Mat& img);

	/**
	 * @brief use hough transform to detect lines in a given window
	 *
	 * @param win
	 */
	void houghLineDetection(const int* win);

	/**
	 * @brief  tracking is done here
	 */
	void track(void);

	/**
	 * @brief  I still don't know how to read the model from the wrl or cad or cao file
	 * However, it is sufficient to get the cube from the init file
	 * if in the future, more complex model is tracked, I should reimplement this function
	 */
	void initModel(std::vector<cv::Point3f>& initP);
	

	/**
	 * @brief  project the model into the image using the provided  pose (usually the predicted one or the measured one)
	 *
	 * @param cMo_
	 */
	void projectModel(const vpHomogeneousMatrix& cMo_);

	/**
	 * @brief  initialize the Kalman filter, such as the measurement matrix etc.
	 */
	void initKalman(void);

	/**
	 * @brief  link the detected line with the visible line
	 */
	void makeConnection(void);

	/**
	 * @brief  measure pose from the connected features
	 */
	void measurePose(void);

// utility functions
protected:
	/**
	 * @brief  calculate the "distance" between two lines
	 *
	 * @param l1
	 * @param l2
	 * @param ml1
	 * @param dl2
	 *
	 * @return 
	 */
	double compareStraightLine(const vpLine& l1, const vpLine& l2, const cv::Vec4f& ml1, const cv::Vec4f& dl2);

	/**
	 * @brief  give three points in a panel, get the equation of the panel
	 *
	 * @param pt
	 * @param a
	 * @param b
	 * @param c
	 * @param d
	 */
	void getPanelEquFromThreePt(const std::vector<cv::Point3f>& pt, 
			double& a, double& b, double& c, double& d);

	/**
	 * @brief  transform the line segment into straight line
	 *
	 * @param line_
	 * @param sl
	 */
	void transLineType(const cv::Vec4f& line_, vpLine& sl);

	/**
	 * @brief  generate a window for hough transform
	 */
	void genTrackingWindow(void);

	/**
	 * @brief  find visible lines using the vpMbtPolygon class
	 *
	 * @param cMo_
	 */
	void findVisibleLines(const vpHomogeneousMatrix& cMo_);

	/**
	 * @brief  find two faces that generate the line
	 *
	 * @param lineID
	 * @param f1
	 * @param f2
	 */
	void line2face(const int lineID, int& f1, int& f2);

	/**
	 * @brief  get the end points IDs from the line ID
	 *
	 * @param lineID
	 * @param p1
	 * @param p2
	 */
	void line2Pts(const int lineID, int& p1, int& p2); 

	/**
	 * @brief  get the line equation in 3D coordinate system form the line ID
	 *
	 * @param ID
	 * @param a1
	 * @param b1
	 * @param c1
	 * @param d1
	 * @param a2
	 * @param b2
	 * @param c2
	 * @param d2
	 */
	void getLineEquFromID(int ID, double& a1,double& b1,double& c1,double& d1,double& a2,double& b2,double& c2,double& d2);

	/**
	 * @brief  get the line equation in 2D coordinate system with two given points
	 * ax + by + c = 0
	 *
	 * @param line_
	 * @param a
	 * @param b
	 * @param c
	 */
	void getPrjLineEqu(const cv::Vec4f& line_, double& a, double& b, double& c);

	/**
	 * @brief  the cross point of two straight lines
	 *
	 * @param l1
	 * @param l2
	 * @param x
	 * @param y
	 */
	void getPtFromStraightLine(int l1, int l2, double& x, double& y);

	/**
	 * @brief  check the order of endpoints of a given segment
	 * just to make sure the line segment is in front of the camera
	 *
	 * @param x1
	 * @param y1
	 * @param x2
	 * @param y2
	 * @param w1
	 * @param w2
	 *
	 * @return 
	 */
	bool checkPtsConnection(double x1, double y1, double x2, double y2, const cv::Point3f& w1, const cv::Point3f& w2);

	/**
	 * @brief  distance between two points
	 *
	 * @param x1
	 * @param y1
	 * @param x2
	 * @param y2
	 *
	 * @return 
	 */
	inline double ptsDist(double x1, double y1, double x2, double y2);

	/**
	 * @brief  distance between two poseVector
	 *
	 * @param p1
	 * @param p2
	 *
	 * @return 
	 */
	inline double poseDist(const vpPoseVector& p1, const vpPoseVector& p2);

	/**
	 * @brief check whether the pose estimated is flipped
	 *
	 * @param p1
	 * @param p2
	 *
	 * @return 
	 */
	bool isFlipped(const vpPoseVector& p1, const vpPoseVector& p2);

};
